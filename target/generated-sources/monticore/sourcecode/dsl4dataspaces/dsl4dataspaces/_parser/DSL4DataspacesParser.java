/* generated from model DSL4Dataspaces */
/* generated by template cd2java.Class*/

/* (c) https://github.com/MontiCore/monticore */

/* Hookpoint: ClassContent:addComment */

/* generated by template cd2java.Package*/
package dsl4dataspaces.dsl4dataspaces._parser;


/* generated by template cd2java.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.se_rwth.commons.SourcePosition;



/* Hookpoint: ClassContent:Imports */



/* Hookpoint: ClassContent:Annotations */

 public  class DSL4DataspacesParser extends de.monticore.antlr4.MCConcreteParser  {

/* Hookpoint: ClassContent:Elements */



    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 protected  DSL4DataspacesAntlrParser create (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.Create*/

  DSL4DataspacesAntlrLexer lexer = new DSL4DataspacesAntlrLexer(org.antlr.v4.runtime.CharStreams.fromFileName(fileName));
  org.antlr.v4.runtime.CommonTokenStream tokens = new org.antlr.v4.runtime.CommonTokenStream(lexer);
  DSL4DataspacesAntlrParser parser = new DSL4DataspacesAntlrParser(tokens);
  lexer.setMCParser(parser);
  lexer.removeErrorListeners();
  lexer.addErrorListener(new de.monticore.antlr4.MCErrorListener(parser));
  parser.setFilename(fileName);
  setError(false);
  return parser;
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 protected  DSL4DataspacesAntlrParser create (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.CreateReader*/

  DSL4DataspacesAntlrLexer lexer = new DSL4DataspacesAntlrLexer(org.antlr.v4.runtime.CharStreams.fromReader(reader));
  org.antlr.v4.runtime.CommonTokenStream tokens = new org.antlr.v4.runtime.CommonTokenStream(lexer);
  DSL4DataspacesAntlrParser parser = new DSL4DataspacesAntlrParser(tokens);
  lexer.setMCParser(parser);
  lexer.removeErrorListeners();
  lexer.addErrorListener(new de.monticore.antlr4.MCErrorListener(parser));
  parser.setFilename("StringReader");
  setError(false);
  return parser;
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDataSpaceConnectorConfiguration> parse (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.Parse*/

  return parseDataSpaceConnectorConfiguration(fileName);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDataSpaceConnectorConfiguration> parse (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseReader*/

  return parseDataSpaceConnectorConfiguration(reader);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDataSpaceConnectorConfiguration> parse_String (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseString*/

  return parse_StringDataSpaceConnectorConfiguration(str);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDataSpaceConnectorConfiguration> parseDataSpaceConnectorConfiguration (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTDataSpaceConnectorConfiguration ast;
  ast = parser.dataSpaceConnectorConfiguration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDataSpaceConnectorConfiguration> parseDataSpaceConnectorConfiguration (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTDataSpaceConnectorConfiguration ast;
  ast = parser.dataSpaceConnectorConfiguration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDataSpaceConnectorConfiguration> parse_StringDataSpaceConnectorConfiguration (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseDataSpaceConnectorConfiguration(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTComplexName> parseComplexName (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTComplexName ast;
  ast = parser.complexName().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTComplexName> parseComplexName (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTComplexName ast;
  ast = parser.complexName().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTComplexName> parse_StringComplexName (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseComplexName(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDiscoveryData> parseDiscoveryData (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTDiscoveryData ast;
  ast = parser.discoveryData().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDiscoveryData> parseDiscoveryData (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTDiscoveryData ast;
  ast = parser.discoveryData().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTDiscoveryData> parse_StringDiscoveryData (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseDiscoveryData(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTAssetMetaData> parseAssetMetaData (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTAssetMetaData ast;
  ast = parser.assetMetaData().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTAssetMetaData> parseAssetMetaData (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTAssetMetaData ast;
  ast = parser.assetMetaData().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTAssetMetaData> parse_StringAssetMetaData (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseAssetMetaData(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTBaseUsage> parseBaseUsage (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTBaseUsage ast;
  ast = parser.baseUsage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTBaseUsage> parseBaseUsage (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTBaseUsage ast;
  ast = parser.baseUsage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTBaseUsage> parse_StringBaseUsage (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBaseUsage(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTOPCUAUsage> parseOPCUAUsage (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTOPCUAUsage ast;
  ast = parser.oPCUAUsage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTOPCUAUsage> parseOPCUAUsage (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTOPCUAUsage ast;
  ast = parser.oPCUAUsage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTOPCUAUsage> parse_StringOPCUAUsage (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseOPCUAUsage(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTEDCUsage> parseEDCUsage (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTEDCUsage ast;
  ast = parser.eDCUsage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTEDCUsage> parseEDCUsage (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTEDCUsage ast;
  ast = parser.eDCUsage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTEDCUsage> parse_StringEDCUsage (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseEDCUsage(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTEDCPushEndpointsConfig> parseEDCPushEndpointsConfig (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTEDCPushEndpointsConfig ast;
  ast = parser.eDCPushEndpointsConfig().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTEDCPushEndpointsConfig> parseEDCPushEndpointsConfig (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTEDCPushEndpointsConfig ast;
  ast = parser.eDCPushEndpointsConfig().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTEDCPushEndpointsConfig> parse_StringEDCPushEndpointsConfig (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseEDCPushEndpointsConfig(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTAccessPolicy> parseAccessPolicy (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTAccessPolicy ast;
  ast = parser.accessPolicy().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTAccessPolicy> parseAccessPolicy (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTAccessPolicy ast;
  ast = parser.accessPolicy().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTAccessPolicy> parse_StringAccessPolicy (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseAccessPolicy(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTRole> parseRole (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTRole ast;
  ast = parser.role().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTRole> parseRole (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTRole ast;
  ast = parser.role().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTRole> parse_StringRole (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseRole(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTIdentityProviderConfig> parseIdentityProviderConfig (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTIdentityProviderConfig ast;
  ast = parser.identityProviderConfig().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTIdentityProviderConfig> parseIdentityProviderConfig (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTIdentityProviderConfig ast;
  ast = parser.identityProviderConfig().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTIdentityProviderConfig> parse_StringIdentityProviderConfig (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseIdentityProviderConfig(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTOAuthInfo> parseOAuthInfo (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTOAuthInfo ast;
  ast = parser.oAuthInfo().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTOAuthInfo> parseOAuthInfo (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTOAuthInfo ast;
  ast = parser.oAuthInfo().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTOAuthInfo> parse_StringOAuthInfo (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseOAuthInfo(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTConfigurationElements> parseConfigurationElements (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTConfigurationElements ast;
  ast = parser.configurationElements().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTConfigurationElements> parseConfigurationElements (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTConfigurationElements ast;
  ast = parser.configurationElements().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTConfigurationElements> parse_StringConfigurationElements (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseConfigurationElements(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTUsage> parseUsage (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  dsl4dataspaces.dsl4dataspaces._ast.ASTUsage ast;
  ast = parser.usage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTUsage> parseUsage (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  dsl4dataspaces.dsl4dataspaces._ast.ASTUsage ast;
  ast = parser.usage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<dsl4dataspaces.dsl4dataspaces._ast.ASTUsage> parse_StringUsage (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseUsage(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName> parseMCQualifiedName (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName ast;
  ast = parser.mCQualifiedName().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName> parseMCQualifiedName (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName ast;
  ast = parser.mCQualifiedName().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName> parse_StringMCQualifiedName (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCQualifiedName(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration> parseMCPackageDeclaration (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration ast;
  ast = parser.mCPackageDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration> parseMCPackageDeclaration (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration ast;
  ast = parser.mCPackageDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration> parse_StringMCPackageDeclaration (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCPackageDeclaration(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCImportStatement> parseMCImportStatement (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCImportStatement ast;
  ast = parser.mCImportStatement().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCImportStatement> parseMCImportStatement (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCImportStatement ast;
  ast = parser.mCImportStatement().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCImportStatement> parse_StringMCImportStatement (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCImportStatement(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType> parseMCPrimitiveType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType ast;
  ast = parser.mCPrimitiveType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType> parseMCPrimitiveType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType ast;
  ast = parser.mCPrimitiveType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType> parse_StringMCPrimitiveType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCPrimitiveType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType> parseMCQualifiedType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType ast;
  ast = parser.mCQualifiedType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType> parseMCQualifiedType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType ast;
  ast = parser.mCQualifiedType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType> parse_StringMCQualifiedType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCQualifiedType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCReturnType> parseMCReturnType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCReturnType ast;
  ast = parser.mCReturnType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCReturnType> parseMCReturnType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCReturnType ast;
  ast = parser.mCReturnType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCReturnType> parse_StringMCReturnType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCReturnType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCVoidType> parseMCVoidType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCVoidType ast;
  ast = parser.mCVoidType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCVoidType> parseMCVoidType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCVoidType ast;
  ast = parser.mCVoidType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCVoidType> parse_StringMCVoidType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCVoidType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCType> parseMCType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCType ast;
  ast = parser.mCType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCType> parseMCType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCType ast;
  ast = parser.mCType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCType> parse_StringMCType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCObjectType> parseMCObjectType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCObjectType ast;
  ast = parser.mCObjectType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCObjectType> parseMCObjectType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCObjectType ast;
  ast = parser.mCObjectType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCObjectType> parse_StringMCObjectType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCObjectType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTIntLiteral> parseIntLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mcjavaliterals._ast.ASTIntLiteral ast;
  ast = parser.intLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTIntLiteral> parseIntLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mcjavaliterals._ast.ASTIntLiteral ast;
  ast = parser.intLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTIntLiteral> parse_StringIntLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseIntLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTLongLiteral> parseLongLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mcjavaliterals._ast.ASTLongLiteral ast;
  ast = parser.longLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTLongLiteral> parseLongLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mcjavaliterals._ast.ASTLongLiteral ast;
  ast = parser.longLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTLongLiteral> parse_StringLongLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseLongLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTFloatLiteral> parseFloatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mcjavaliterals._ast.ASTFloatLiteral ast;
  ast = parser.floatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTFloatLiteral> parseFloatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mcjavaliterals._ast.ASTFloatLiteral ast;
  ast = parser.floatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTFloatLiteral> parse_StringFloatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseFloatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTDoubleLiteral> parseDoubleLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mcjavaliterals._ast.ASTDoubleLiteral ast;
  ast = parser.doubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTDoubleLiteral> parseDoubleLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mcjavaliterals._ast.ASTDoubleLiteral ast;
  ast = parser.doubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcjavaliterals._ast.ASTDoubleLiteral> parse_StringDoubleLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseDoubleLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNullLiteral> parseNullLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTNullLiteral ast;
  ast = parser.nullLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNullLiteral> parseNullLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTNullLiteral ast;
  ast = parser.nullLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNullLiteral> parse_StringNullLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseNullLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral> parseBooleanLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral ast;
  ast = parser.booleanLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral> parseBooleanLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral ast;
  ast = parser.booleanLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral> parse_StringBooleanLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBooleanLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTCharLiteral> parseCharLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTCharLiteral ast;
  ast = parser.charLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTCharLiteral> parseCharLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTCharLiteral ast;
  ast = parser.charLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTCharLiteral> parse_StringCharLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseCharLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTStringLiteral> parseStringLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTStringLiteral ast;
  ast = parser.stringLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTStringLiteral> parseStringLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTStringLiteral ast;
  ast = parser.stringLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTStringLiteral> parse_StringStringLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseStringLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNatLiteral> parseNatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTNatLiteral ast;
  ast = parser.natLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNatLiteral> parseNatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTNatLiteral ast;
  ast = parser.natLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNatLiteral> parse_StringNatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseNatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral> parseSignedNatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral ast;
  ast = parser.signedNatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral> parseSignedNatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral ast;
  ast = parser.signedNatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral> parse_StringSignedNatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedNatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral> parseBasicLongLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral ast;
  ast = parser.basicLongLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral> parseBasicLongLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral ast;
  ast = parser.basicLongLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral> parse_StringBasicLongLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBasicLongLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral> parseSignedBasicLongLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral ast;
  ast = parser.signedBasicLongLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral> parseSignedBasicLongLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral ast;
  ast = parser.signedBasicLongLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral> parse_StringSignedBasicLongLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedBasicLongLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral> parseBasicFloatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral ast;
  ast = parser.basicFloatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral> parseBasicFloatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral ast;
  ast = parser.basicFloatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral> parse_StringBasicFloatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBasicFloatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral> parseSignedBasicFloatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral ast;
  ast = parser.signedBasicFloatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral> parseSignedBasicFloatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral ast;
  ast = parser.signedBasicFloatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral> parse_StringSignedBasicFloatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedBasicFloatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral> parseBasicDoubleLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral ast;
  ast = parser.basicDoubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral> parseBasicDoubleLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral ast;
  ast = parser.basicDoubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral> parse_StringBasicDoubleLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBasicDoubleLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral> parseSignedBasicDoubleLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral ast;
  ast = parser.signedBasicDoubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral> parseSignedBasicDoubleLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral ast;
  ast = parser.signedBasicDoubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral> parse_StringSignedBasicDoubleLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedBasicDoubleLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral> parseSignedLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral ast;
  ast = parser.signedLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral> parseSignedLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral ast;
  ast = parser.signedLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral> parse_StringSignedLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral> parseNumericLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral ast;
  ast = parser.numericLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral> parseNumericLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral ast;
  ast = parser.numericLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral> parse_StringNumericLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseNumericLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral> parseSignedNumericLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral ast;
  ast = parser.signedNumericLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral> parseSignedNumericLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral ast;
  ast = parser.signedNumericLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral> parse_StringSignedNumericLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedNumericLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcliteralsbasis._ast.ASTLiteral> parseLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  DSL4DataspacesAntlrParser parser = create(fileName);
  de.monticore.literals.mcliteralsbasis._ast.ASTLiteral ast;
  ast = parser.literal().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcliteralsbasis._ast.ASTLiteral> parseLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  DSL4DataspacesAntlrParser parser = create(reader);
  de.monticore.literals.mcliteralsbasis._ast.ASTLiteral ast;
  ast = parser.literal().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcliteralsbasis._ast.ASTLiteral> parse_StringLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseLiteral(new java.io.StringReader(str));
}


}


